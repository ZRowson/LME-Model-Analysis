---
title: "Week of 05-23-2022 Pt 2"
author: "Zachary Rowson"
date: "5/26/2022"
output: 
  html_document:
    code_folding: hide
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache=TRUE)
library(nlme)
library(lattice)
library(data.table)
library(ggplot2)
library(gabi)
```

## Introduction

In this document I will fit models to 10 chemical exposure groups and evaluate the residuals of the model to determine if, overall, assumptions on within group residuals are violated for this dataset.

## Fit to 10 Data Sets

These are the 10 chemicals whose exposure data we will model.

```{r, choose-chms}
load("../data/Padilla_DNT60_pmr0_long.rda")
DNT60_data <- gabi::data_egids(DNT60pmr0_long)

chemicals <- DNT60pmr0_long[, unique(cpid)]
set.seed(2)
chms.toFit <- sample(chemicals, 10)
chms.toFit
names(chms.toFit) <- chms.toFit
```

Fit LMEs to these data.

```{r, createNest-function}
createNest <- function(chm) {
  
            # Isolate chemical exposure data
            group <- DNT60_data[cpid==chm, unique(egid)]
            exposure.data <- DNT60_data[cpid==chm | (wllt=="v"&egid==group)]
            
            # Remove poor quality individuals
            remove <- exposure.data[is.na(y), unique(fishID)]

            # Split data by experimental phase
            data <- copy(exposure.data)
            data.L <- data[t%in%11:30]
            data.D <- data[t%in%31:50]

            # Shift time measurements and save concentration as a factor
            data.L$t <- data.L$t - mean(data.L$t)
            data.L$conc <- as.factor(data.L$conc)
            data.D$t <- data.D$t - mean(data.D$t)
            data.D$conc <- as.factor(data.D$conc)

            # Add well location, inside vs. outside, as co-variate
            data.L[rowi%in%c(1,8), well_loc:="outside"][coli%in%c(1,12), well_loc:="outside"]
            data.L[is.na(well_loc), well_loc:="inside"]
            data.D[rowi%in%c(1,8), well_loc:="outside"][coli%in%c(1,12), well_loc:="outside"]
            data.D[is.na(well_loc), well_loc:="inside"]

            # Transform data
            data.L.sqrt <- copy(data.L)
            data.L.sqrt[, sqrty := sqrt(y)]
            data.D.sqrt <- copy(data.D)
            data.D.sqrt[, sqrty := sqrt(y)]

            # Define hierarchical structure
            Light.sqrt <- groupedData(sqrty ~ t | fishID, data = as.data.frame(data.L.sqrt[!(fishID%in%remove)]), order.groups = FALSE)
            Dark.sqrt <- groupedData(sqrty ~ t | fishID, data = as.data.frame(data.D.sqrt[!(fishID%in%remove)]), order.groups = FALSE)
            
            return(list(Light.sqrt = Light.sqrt,
                        Dark.sqrt = Dark.sqrt))
}
```
```{r, fitLME-function}
fitLME <- function(data, ctrl) {
  
            lmm <- lme(sqrty ~ conc*poly(t,degree=2,raw=TRUE),
                         data = data,
                         random = reStruct(~poly(t,degree=2,raw=TRUE)|fishID,REML=TRUE,pdClass="pdSymm"),
                         correlation = corAR1(,form=~t|fishID),
                         method = "REML",
                         control = ctrl)
            
            return(lmm)
}
```
```{r, apply-functions, warning=FALSE}
# Create nested data
nests <- lapply(chms.toFit, createNest)

# Fit to nested data
ctrl <- lmeControl(opt = "optim", niterEM = 200, msTol = 1e-20, msMaxIter = 1000, apVar = FALSE)
fits <- lapply(nests, function(chm) lapply(chm, fitLME, ctrl=ctrl))
```

```{r, eval-qqnorm}
invisible(lapply(fits, function(chm) lapply(chm, function(fit) {
                                              if (identical(chm[[1]],fit)) {
                                                phase <- "Light"
                                              } else {
                                                phase <- "Dark"
                                              }
                                              
                                              name <- unique( fit$data$cpid[fit$data$wllt=="t"] )
                                              qqnorm(resid(fit), main = paste(name,"in",phase,sep=" "))
                                              qqline(resid(fit))
  })))
```

Overall Light models appear to meet conditions fairly well. For Dark models it appears the skew towards the negative direction is most common. Evaluation of the affect of this directional skew on the parameter estimates will be important. Prior evaluation of the effect of log normal skew on data revealed that skew had little effect on parameter estimates. However, that simulation did not properly imitate the underlying distributions of the data in the Dark. Providing this simulation may better reveal issues generated by these non-normal distributions.

## Refit Models in Light with Variance Function

I haven't managed to get these models to converge with REML methods, but fit them with ML despite this. Some models won't converge, but evaluate benefit to AIC and qqnorm plots for those that do.

```{r, fitLME-varFunction}
fitLME.varFunc <- function(data, ctrl) {
  
            return(tryCatch(lme(sqrty ~ conc*poly(t,degree=2,raw=TRUE),
                         data = data,
                         random = reStruct(~poly(t,degree=2,raw=TRUE)|fishID,REML=FALSE,pdClass="pdSymm"),
                         correlation = corAR1(,form=~t|fishID),
                         method = "ML",
                         weights = varConstPower(),
                         control = ctrl), 
                     error=function(e) NULL))
}
```
```{r, refit-Light, warning=FALSE}
ctrl <- lmeControl(opt = "optim", niterEM = 200, msTol = 1e-10, msMaxIter = 1000, apVar = FALSE)
reFits.Light <- lapply(nests, function(chm) fitLME.varFunc(chm[[1]],ctrl=ctrl))
```

Evaluate change in AIC when variance function is included. Negative values indicate improvement in AIC with the inclusion of the variance function. 

```{r, eval-AIC}
reFits.Light2 <- reFits.Light[c(2:4,6:10)]
AIC_fitsL.2 <- lapply(reFits.Light2, AIC)
AIC_fitsL <- lapply(fits[c(2:4,6:10)], function(chm) AIC(chm[[1]]))

unlist(AIC_fitsL.2) - unlist(AIC_fitsL)
```

For the models that are fit addition of variance function helps models immensely.

Evaluate is there are visible changes in the normality of the residuals.

```{r, plot-qq-varFunc, message=FALSE}
invisible(lapply(1:8, function(i) {
                      fit.1 <- fits[c(2:4,6:10)][[i]][["Light.sqrt"]]
                      fit.2 <- reFits.Light2[[i]]
                      name <- unique( fit.1$data$cpid[fit.1$data$wllt=="t"] )
                      par(mfrow=c(1,2))
                      qqnorm(resid(fit.1), main = paste(name,"in Light",sep=" "))
                      qqline(resid(fit.1))
                      qqnorm(resid(fit.2), main = paste(name,"in Light w/ varFunc",sep=" "))
                      qqline(resid(fit.2))
  }))
```

Effect on residuals isn't that obvious. It seems that the largest effect is in re-evaluating extreme values and how extreme they actually are.
